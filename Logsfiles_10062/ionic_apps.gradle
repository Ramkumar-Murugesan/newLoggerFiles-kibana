import org.gradle.api.tasks.Exec
import groovy.json.*

buildscript {
  repositories {
    jcenter()
    maven {
      url "https://plugins.gradle.org/m2/"
    }
  }
  dependencies {
    classpath 'org.hidetake:gradle-ssh-plugin:1.1.3'
  }
}

apply plugin: 'org.hidetake.ssh'

project.ext {
  androidProjectFolder = projects_folder + '/mobile/android'
  iosProjectFolder = projects_folder + '/mobile/ios/' + propProjectName
  tabletandroid = projects_folder + '/tablet/android'
  tabletios = projects_folder + '/tablet/ios/' + propProjectName
  apkFolder = androidProjectFolder + '/platforms/android/build/outputs/apk/'
  tabletapkfolder = tabletandroid + '/platforms/android/build/outputs/apk/'
  appid=''
  tabletappid=''
  appToken=''
  tabletappToken=''
  appStatus =''
  tabletappStatus =''
  output=''
  appLink=''
  iosAppName = ''
}

repositories {
  mavenCentral()
}

configurations {
  antClasspath
}

dependencies {
  antClasspath 'ant:ant-javamail:1.6.5', 'javax.activation:activation:1.1.1', 'javax.mail:mail:1.5.0-b01'
}

ClassLoader antClassLoader = org.apache.tools.ant.Project.class.classLoader
configurations.antClasspath.each { File jar ->
  antClassLoader.addURL( jar.toURI().toURL() )
}

def android_folder = new File(androidProjectFolder)
def IOS_folder = new File(iosProjectFolder)
def tablet_android = new File(tabletandroid)
def tablet_ios = new File(tabletios)

remotes {
  webServer {
    host = propSSHHostName
    user = propSSHUsername
    password = propSSHPassword
    knownHosts = allowAnyHosts
  }
}

def executeCmd(command) {
  def proc = command.execute()
  proc.waitFor()
  println proc.err.text
  println proc.in.text
}

//Build Section

//tablet section
task resettabletProject<<{
  exec{
    workingDir = tabletandroid
    commandLine 'ionic','state','reset'
  }
}
resettabletProject.onlyIf {tablet_android.exists()}

task createtabletAPk(dependsOn :'resettabletProject')<<{
  exec{
    workingDir = tabletandroid
    commandLine 'ionic','build','android'
  }
}
createtabletAPk.onlyIf {tablet_android.exists()}

task uploadtabletAPk(dependsOn:'createtabletAPk') << {
  println 'APk generated'
  def kk='pwd'.execute().text
  println kk
   exec {
   commandLine 'echo','------------------------------------'
   commandLine 'bash', 'uploadAPK.sh', 'executetablet'
  }
}
uploadtabletAPk.onlyIf {tablet_android.exists()}

task gettabletAppId(dependsOn:'uploadtabletAPk')<< {
  def json = new JsonSlurper().parse(file (tabletandroid + tabletApkUploadSucessJson),"UTF-8")
  tabletappid=json.appData.latestBuild.id
  tabletappToken=json.appData.latestBuild.buildFile.url
  println "--------------latestBuild----------- \n" +json.appData.latestBuild.id
  println '----------------installr Url--------- \n'+json.appData.latestBuild.buildFile.url
}
gettabletAppId.onlyIf {tablet_android.exists()}

task tabletapkUrlDownload(dependsOn:'gettabletAppId') << {
  println tabletappToken
  String x=tabletappToken
  String[] token=x.tokenize(".")
  String [] v=token[2].tokenize("/")
  println 'final url for APK -----'+'https://www.installrapp.com/apk/'+tabletappid+'/'+v[3]
  tabletappStatus= 'https://www.installrapp.com/apk/'+tabletappid+'/'+v[3]
}
tabletapkUrlDownload.onlyIf {tablet_android.exists()}

task sendNotifyEmailForTabletAPK(dependsOn: 'tabletapkUrlDownload') << {
  def mailParams = [
    mailhost: propEmailHost,
    mailport: propEmailPort,
    ssl: true,
    user: propEmailUsername,
    password: propEmailPassword,
    messagemimetype: propEmailContentType,
    subject: propTabletEmailSubject
  ]

  def messageBody = androidTabletEmailBody.replace("*|APP_URL|*", tabletappStatus)
  messageBody = messageBody.replace("*|GEPPETTO_URL|*", propGeppettoUrl)
  ant.mail (mailParams) {
    from(address: propEmailSender)
    to(address: propEmailReceiver)
    message(messageBody)
    fileset(file: propEmailAttachment)
  }
  println 'Email notification has been sent for Android application!'
}
sendNotifyEmailForTabletAPK.onlyIf {tablet_android.exists()}

task tabletiosApp(dependsOn:'sendNotifyEmailForTabletAPK') << {
  String [] v = propiOSProjectDirPath.tokenize("/")
  iosAppName=v[v.length-1]
  println '-----'+iosAppName
}
tabletiosApp.onlyIf {tablet_ios.exists()}

// Doing SSH with Mac Server to Kick the iOS Generation
task tablet_sshToMacServer(dependsOn: 'tabletiosApp') << {
  ssh.run {
    println '\nConnecting to Mac server...'
    session(remotes.webServer) {
      println 'Connected to Mac server!'
      execute 'test -d  /Users/administrator/Documents/'+iosAppName+'_tablet'+'  && echo "Workspace already exists!" || mkdir  Documents/'+iosAppName+'_tablet'
      execute 'test -d ' + propiOSProjectDirPath+'_tablet' + ' && echo "Workspace already exists!" || mkdir ' + propiOSProjectDirPath +'_tablet'
      println 'File transfering started to Mac server!'
      execute 'test -d ' + propiOSProjectDirPath +'_tablet' + ' && echo "WebContent workspace already exists!" || mkdir ' + propiOSProjectDirPath +'_tablet'
      put from: tabletios, into: propiOSProjectDirPath+'_tablet'
      put from: propScriptSourceDirName + '/build.gradle', into: propiOSProjectDirPath +'_tablet'
      put from: propScriptSourceDirName + '/gradle.properties', into: propiOSProjectDirPath+'_tablet'
      put from: propScriptSourceDirName + '/generate.sh', into: propiOSProjectDirPath+'_tablet'
      put from: propScriptSourceDirName + '/exec_tablet.sh', into: propiOSProjectDirPath+'_tablet'
      put from: propScriptSourceDirName + '/sendInvites.sh', into: propiOSProjectDirPath+'_tablet'
      println 'File transfer has been finished!'
      println 'iOS application generation was started!'
      execute 'sed -e \'s/\r$//\' ' + propiOSProjectDirPath+'_tablet' + '/generate.sh > ' + propiOSProjectDirPath+'_tablet' + '/start_execution.sh'
      execute 'sed -e \'s/\r$//\' ' + propiOSProjectDirPath+'_tablet' + '/exec_tablet.sh > ' + propiOSProjectDirPath+'_tablet' + '/executable.sh'
      execute 'chmod +x ' + propiOSProjectDirPath+'_tablet' + '/start_execution.sh'
      execute 'chmod +x ' + propiOSProjectDirPath +'_tablet'+ '/executable.sh'
      execute '/bin/sh -c "sleep 20 ; echo GradleScript_for_IOS_App_Triggered_in_Mac"'
      def appname = iosAppName 
        def userid = gpuserid 
        def path =  propiOSProjectDirPath+'_tablet'
        def installrac = installrToken
        def status = "Transfer_finished"

        def json = new JsonBuilder()
        def root = json appname: appname, userid: userid, path: path, installrac: installrac, status: status

        print json.toString()
       exec{
       commandLine 'curl','-H','Content-Type: application/json','POST','http://'+propSSHHostName+':8080/IPA_Details/create_IPA_Details/', '-d',json.toString() 
    }
      println 'Tablet iOS application has been generated and uploaded to installr!'
    }
  }
}
tablet_sshToMacServer.onlyIf {tablet_ios.exists()}

task deployTabletApss(dependsOn: 'tablet_sshToMacServer'){
  doLast{
    println 'Tablet Apps deployed!'
  }
}

//mobile section

task resetIonicProject<<{
  exec{
    workingDir = androidProjectFolder
    commandLine 'ionic','state','reset'
  }
}
resetIonicProject.onlyIf {android_folder.exists()}

task createAPk(dependsOn :'resetIonicProject')<<{
  exec{
    workingDir = androidProjectFolder
    commandLine 'ionic','build','android'
  }
}
createAPk.onlyIf {android_folder.exists()}

task uploadAPk(dependsOn:'createAPk') << {
  println 'APk generated'
  def kk='pwd'.execute().text
  println kk
  exec {
    commandLine 'echo','------------------------------------'
   commandLine 'bash', 'uploadAPK.sh' , 'executemobile'
  }
}
uploadAPk.onlyIf {android_folder.exists()}

task getAppId(dependsOn:'uploadAPk')<< {
  def json = new JsonSlurper().parse(file (androidProjectFolder + propApkUpSuccesJson),"UTF-8")
  appid=json.appData.latestBuild.id
  appToken=json.appData.latestBuild.buildFile.url
  println "--------------latestBuild----------- \n" +json.appData.latestBuild.id
  println '----------------installr Url--------- \n'+json.appData.latestBuild.buildFile.url
}
getAppId.onlyIf {android_folder.exists()}

task apkUrlDownload(dependsOn:'getAppId') << {
  println appToken
  String x=appToken
  String[] token=x.tokenize(".")
  String [] v=token[2].tokenize("/")
  println 'final url for APK -----'+'https://www.installrapp.com/apk/'+appid+'/'+v[3]
  appStatus= 'https://www.installrapp.com/apk/'+appid+'/'+v[3]
}
apkUrlDownload.onlyIf {android_folder.exists()}

task sendNotifyEmailForAPK(dependsOn: 'apkUrlDownload') << {
  def mailParams = [
    mailhost: propEmailHost,
    mailport: propEmailPort,
    ssl: true,
    user: propEmailUsername,
    password: propEmailPassword,
    messagemimetype: propEmailContentType,
    subject: propEmailSubject
  ]

  def messageBody = androidEmailBody.replace("*|APP_URL|*", appStatus)
  messageBody = messageBody.replace("*|GEPPETTO_URL|*", propGeppettoUrl)
  ant.mail (mailParams) {
    from(address: propEmailSender)
    to(address: propEmailReceiver)
    message(messageBody)
    fileset(file: propEmailAttachment)
  }
  println 'Email notification has been sent for Android application!'
}
sendNotifyEmailForAPK.onlyIf {android_folder.exists()}

task iosApp(dependsOn:'sendNotifyEmailForAPK') << {
  String [] v = propiOSProjectDirPath.tokenize("/")
  iosAppName=v[v.length-1]
  println '-----'+iosAppName
}
iosApp.onlyIf {IOS_folder.exists()}

// Doing SSH with Mac Server to Kick the iOS Generation
task sshToMacServer(dependsOn: 'iosApp') << {
  ssh.run {
    println '\nConnecting to Mac server...'
    session(remotes.webServer) {
      println 'Connected to Mac server!'
      execute 'test -d  /Users/administrator/Documents/'+iosAppName+'  && echo "Workspace already exists!" || mkdir  Documents/'+iosAppName
      execute 'test -d ' + propiOSProjectDirPath + ' && echo "Workspace already exists!" || mkdir ' + propiOSProjectDirPath
      println 'File transfering started to Mac server!'
      execute 'test -d ' + propiOSProjectDirPath + ' && echo "WebContent workspace already exists!" || mkdir ' + propiOSProjectDirPath
      put from: iosProjectFolder, into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/build.gradle', into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/gradle.properties', into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/generate.sh', into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/exec.sh', into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/sendInvites.sh', into: propiOSProjectDirPath
      println 'File transfer has been finished!'
      println 'iOS application generation was started!'
      execute 'sed -e \'s/\r$//\' ' + propiOSProjectDirPath + '/generate.sh > ' + propiOSProjectDirPath + '/start_execution.sh'
      execute 'sed -e \'s/\r$//\' ' + propiOSProjectDirPath + '/exec.sh > ' + propiOSProjectDirPath + '/executable.sh'
      execute 'chmod +x ' + propiOSProjectDirPath + '/start_execution.sh'
      execute 'chmod +x ' + propiOSProjectDirPath + '/executable.sh'
      execute '/bin/sh -c "sleep 20 ; echo GradleScript_for_IOS_App_Triggered_in_Mac"'
     
     def appname = iosAppName 
        def userid = gpuserid 
        def path =  propiOSProjectDirPath
        def installrac = installrToken
        def status = "Transfer_finished"

        def json = new JsonBuilder()
        def root = json appname: appname, userid: userid, path: path, installrac: installrac, status: status

        print json.toString() 
       exec{
       commandLine 'curl','-H','Content-Type: application/json','POST','http://'+propSSHHostName+':8080/IPA_Details/create_IPA_Details/', '-d',json.toString() 
    }
      println 'iOS application has been generated and uploaded to installr!'
    }
  }
}
sshToMacServer.onlyIf {IOS_folder.exists()}

task deployIonicApss(dependsOn: 'sshToMacServer'){
  doLast{
    println 'Ionic Apps deployed!'
  }
}
