import org.gradle.api.tasks.Exec
import groovy.json.*

buildscript {
  repositories {
    jcenter()
    maven {
      url "https://plugins.gradle.org/m2/"
    }
  }
  dependencies {
    classpath 'org.hidetake:gradle-ssh-plugin:1.1.3'
  }
}

apply plugin: 'org.hidetake.ssh'

project.ext {
  androidProjectFolder = projects_folder + '/mobile/android'
  iosProjectFolder = projects_folder + '/mobile/ios/' + propProjectName
  apkFolder = androidProjectFolder + '/platforms/android/build/outputs/apk/'
  appid=''
  appToken=''
  appStatus =''
  output=''
  appLink=''
  iosAppName = ''
}

repositories {
  mavenCentral()
}

configurations {
  antClasspath
}

dependencies {
  antClasspath 'ant:ant-javamail:1.6.5', 'javax.activation:activation:1.1.1', 'javax.mail:mail:1.5.0-b01'
}

ClassLoader antClassLoader = org.apache.tools.ant.Project.class.classLoader
configurations.antClasspath.each { File jar ->
  antClassLoader.addURL( jar.toURI().toURL() )
}

def android_folder = new File(androidProjectFolder)
def IOS_folder = new File(iosProjectFolder)

remotes {
  webServer {
    host = propSSHHostName
    user = propSSHUsername
    password = propSSHPassword
    knownHosts = allowAnyHosts
  }
}

def executeCmd(command) {
  def proc = command.execute()
  proc.waitFor()
  println proc.err.text
  println proc.in.text
}

//Build Section

task resetIonicProject<<{
  exec{
    workingDir = androidProjectFolder
    commandLine 'ionic','state','reset'
  }
}
resetIonicProject.onlyIf {android_folder.exists()}

task createAPk(dependsOn :'resetIonicProject')<<{
  exec{
    workingDir = androidProjectFolder
    commandLine 'ionic','build','android'
  }
}
createAPk.onlyIf {android_folder.exists()}

task uploadAPk(dependsOn:'createAPk') << {
  println 'APk generated'
  def kk='pwd'.execute().text
  println kk
  executeCmd('sh uploadAPK.sh')
}
uploadAPk.onlyIf {android_folder.exists()}

task getAppId(dependsOn:'uploadAPk')<< {
  def json = new JsonSlurper().parse(file (androidProjectFolder + propApkUpSuccesJson),"UTF-8")
  appid=json.appData.latestBuild.id
  appToken=json.appData.latestBuild.buildFile.url
  println "--------------latestBuild----------- \n" +json.appData.latestBuild.id
  println '----------------installr Url--------- \n'+json.appData.latestBuild.buildFile.url
}
getAppId.onlyIf {android_folder.exists()}

task apkUrlDownload(dependsOn:'getAppId') << {
  println appToken
  String x=appToken
  String[] token=x.tokenize(".")
  String [] v=token[2].tokenize("/")
  println 'final url for APK -----'+'https://www.installrapp.com/apk/'+appid+'/'+v[3]
  appStatus= 'https://www.installrapp.com/apk/'+appid+'/'+v[3]
}
apkUrlDownload.onlyIf {android_folder.exists()}

task sendNotifyEmailForAPK(dependsOn: 'apkUrlDownload') << {
  def mailParams = [
    mailhost: propEmailHost,
    mailport: propEmailPort,
    ssl: true,
    user: propEmailUsername,
    password: propEmailPassword,
    messagemimetype: propEmailContentType,
    subject: propEmailSubject
  ]

  def messageBody = androidEmailBody.replace("*|APP_URL|*", appStatus)
  messageBody = messageBody.replace("*|GEPPETTO_URL|*", propGeppettoUrl)
  ant.mail (mailParams) {
    from(address: propEmailSender)
    to(address: propEmailReceiver)
    message(messageBody)
    fileset(file: propEmailAttachment)
  }
  println 'Email notification has been sent for Android application!'
}
sendNotifyEmailForAPK.onlyIf {android_folder.exists()}

task iosApp(dependsOn:'sendNotifyEmailForAPK') << {
  String [] v = propiOSProjectDirPath.tokenize("/")
  iosAppName=v[v.length-1]
  println '-----'+iosAppName
}
iosApp.onlyIf {IOS_folder.exists()}

// Doing SSH with Mac Server to Kick the iOS Generation
task sshToMacServer(dependsOn: 'iosApp') << {
  ssh.run {
    println '\nConnecting to Mac server...'
    session(remotes.webServer) {
      println 'Connected to Mac server!'
      execute 'test -d  /Users/administrator/Documents/'+iosAppName+'  && echo "Workspace already exists!" || mkdir  Documents/'+iosAppName
      execute 'test -d ' + propiOSProjectDirPath + ' && echo "Workspace already exists!" || mkdir ' + propiOSProjectDirPath
      println 'File transfering started to Mac server!'
      execute 'test -d ' + propiOSProjectDirPath + ' && echo "WebContent workspace already exists!" || mkdir ' + propiOSProjectDirPath
      put from: iosProjectFolder, into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/build.gradle', into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/gradle.properties', into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/generate.sh', into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/exec.sh', into: propiOSProjectDirPath
      put from: propScriptSourceDirName + '/sendInvites.sh', into: propiOSProjectDirPath
      println 'File transfer has been finished!'
      println 'iOS application generation was started!'
      execute 'sed -e \'s/\r$//\' ' + propiOSProjectDirPath + '/generate.sh > ' + propiOSProjectDirPath + '/start_execution.sh'
      execute 'sed -e \'s/\r$//\' ' + propiOSProjectDirPath + '/exec.sh > ' + propiOSProjectDirPath + '/executable.sh'
      execute 'chmod +x ' + propiOSProjectDirPath + '/start_execution.sh'
      execute 'chmod +x ' + propiOSProjectDirPath + '/executable.sh'
      execute '/bin/sh -c "sleep 20 ; echo GradleScript_for_IOS_App_Triggered_in_Mac"'
      execute 'mkdir Documents/'+iosAppName+'/TestAPP'
      println 'iOS application has been generated and uploaded to installr!'
    }
  }
}
sshToMacServer.onlyIf {IOS_folder.exists()}

task deployIonicApss(dependsOn: 'sshToMacServer'){
  doLast{
    println 'Ionic Apps deployed!'
  }
}
